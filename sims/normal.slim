initialize() {
	if (!exists("N")) defineConstant("N", 1e4);
	if (!exists("XOPT")) defineConstant("XOPT", 0.0);
	defineConstant("DT", 0.01);
	defineConstant("ALPHA", 0.2);
	defineConstant("SD", 1.0);
	if (!exists("BURNIN")) defineConstant("BURNIN", 100);
	if (!exists("STEP")) defineConstant("STEP", 1);
	if (!exists("NUMGENS")) defineConstant("NUMGENS", 20);
	if (!exists("MUTRATE")) defineConstant("MUTRATE", 1e-9);
	if (!exists("L")) defineConstant("L", 1e8);
    if (!exists("EPSILON")) defineConstant("EPSILON", c(0, 2, 4, 6, 7, 8, 9, 10, 11, 12));
    defineConstant("OUTFILE", "sim_normal_" + getSeed() + ".repro.tsv");
    defineConstant("POPOUTFILE", "sim_normal_" + getSeed() + ".pop.tsv");
    defineConstant("FIXOUTFILE", "sim_normal_" + getSeed() + ".fix.tsv");
	defineConstant("params", Dictionary("N", N, "EPSILON", EPSILON, "DT", DT, "SD", SD, "XOPT", XOPT, "type", "normal"));
	initializeSLiMModelType("nonWF");
    initializeSLiMOptions(keepPedigrees=T);
	// initializeTreeSeq();
	initializeMutationRate(MUTRATE);
	initializeMutationType("m1", 0.5, "n", 0.0, SD);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	initializeRecombinationRate(1e-8);
    catn("N: " + N
        + " DT: " + DT
        + " ALPHA: " + ALPHA
        + " SD: " + SD
	+ " EPSILON: " + EPSILON
        + " XOPT: " + XOPT
        + " BURNIN: " + BURNIN
        + " MUTRATE: " + MUTRATE
        + " NUMGENS: " + NUMGENS
        + " OUTFILE: " + OUTFILE);
   defineGlobal("POST_BURNIN", F);
}

1 first() {
	sim.addSubpop("p1", N);
	inds = p1.individuals;
	p1.individuals.setValue("effects", rep(0.0, length(EPSILON)));
	p1.individuals.tagF = 0.0;
	writeFile(OUTFILE, params.serialize(format='json'));
	ah = "time";
	bh = "";
	ch = "";
	for (eps in EPSILON) {
		ah = ah + "\tself_" + eps;
		bh = bh + "\tma_" + eps;
		ch = ch + "\tpa_" + eps;
	}
	writeFile(OUTFILE, ah + bh + ch, append=T);
	writeFile(FIXOUTFILE, "time" + "\t" + "num_fixations" + "\t" + "num_mutations" + "\t" + "med_trait" + "\t" + "mad_trait" + "\t" + "mutq.9" + "\t" + "mutq.99" + "\t" + "mutq.999");
	community.rescheduleScriptBlock(s97, ticks=asInteger(BURNIN/DT)-1);
	community.rescheduleScriptBlock(s98, start=asInteger(BURNIN/DT), end=asInteger((BURNIN+NUMGENS)/DT));
	community.rescheduleScriptBlock(s99, ticks=asInteger((BURNIN+NUMGENS)/DT));
}

mutationEffect(m1) {
	return 1.0;
}

first() {
	defineGlobal("POST_BURNIN", community.tick * DT >= BURNIN);
	n = p1.individualCount;
	inds = p1.individuals;
	if (!POST_BURNIN) {
		x = inds.tagF;
	} else {
		x = inds.tagF - XOPT;
	}
	z = exp(ALPHA * x^2);
	dead = (runif(n) < 1 - exp(-DT * z));
	k = sum(dead);
	inds[dead].fitnessScaling = 0.0;
	parents = sample(inds, size=k, replace=F);
	inds.tag = 0;
	parents.tag = 1;
}

reproduction() {
	if (individual.tag > 0) {
		mate = p1.sampleIndividuals(1);
		child = p1.addCrossed(individual, mate);
		if (POST_BURNIN) {
			x = rep(0.0, length(EPSILON));
			s = child.genomes.mutations.selectionCoeff;
			k = findInterval(abs(s), EPSILON);
			for (j in seqAlong(EPSILON)) {
				x[j] = sum(s[k == j]);
			}
			child.setValue("effects", x);
			child.tagF = sum(x);
			child.setValue("ma", individual.getValue("effects"));
			child.setValue("pa", mate.getValue("effects"));
		} else {
			child.tagF = child.sumOfMutationsOfType(m1);
		}
	}
}

2: early() {
	if (community.tick - asInteger(floor(community.tick * DT / STEP) * STEP / DT) == 0) {
      inds = p1.individuals;
      muts = sim.mutations;
      writeFile(FIXOUTFILE,
          community.tick * DT
          + "\t" + sum(sim.mutationFrequencies(NULL) == 1.0)
          + "\t" + length(muts)
          + "\t" + quantile(inds.tagF, 0.5)
          + "\t" + quantile(abs(inds.tagF - quantile(inds.tagF, 0.5)), 0.5)
          + "\t" + quantile(abs(muts.selectionCoeff), 0.9)
          + "\t" + quantile(abs(muts.selectionCoeff), 0.99)
          + "\t" + quantile(abs(muts.selectionCoeff), 0.999)
      , append=T);
    }
}

s97 10000 early() {
	catn("Passed burnin, in tick " + community.tick + ", time " + community.tick/DT);
	for (ind in p1.individuals) {
		x = rep(0.0, length(EPSILON));
		s = ind.genomes.mutations.selectionCoeff;
		k = findInterval(abs(s), EPSILON);
		for (j in seqAlong(EPSILON)) {
			x[j] = sum(s[k == j]);
		}
		ind.setValue("effects", x);
	}
}

s98 10000: early() {
	if (community.tick - asInteger(floor(community.tick * DT) / DT) == 0) {
		inds = p1.individuals;
		children = inds[inds.age < 1/DT];
		for (child in children) {
			outline = paste(c(child.getValue("effects"), child.getValue("ma"), child.getValue("pa")), sep="\t");
			writeFile(OUTFILE, community.tick * DT + "\t" + outline, append=T);
		}
    }
}

s99 12000 late() {
	writeFile(POPOUTFILE, "trait" + "\t" + "age");
	for (ind in p1.individuals) {
		writeFile(POPOUTFILE, ind.tagF + "\t" + ind.age, append=T);
	}
    catn("Done! In tick " + community.tick + ", time " + community.tick/DT);
	sim.simulationFinished();
}
